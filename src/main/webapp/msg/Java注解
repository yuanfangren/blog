## 概念
> 注解是一系列元数据，它提供数据用来解释程序代码，但是注解并非是所解释的代码本身的一部分。注解对于代码的运行效果没有直接影响。注解有许多用处，主要如下： 
- 提供信息给编译器： 编译器可以利用注解来探测错误和警告信息 
- 编译阶段时的处理： 软件工具可以用来利用注解信息来生成代码、Html文档或者做其它相应处理。 
- 运行时的处理： 某些注解可以在程序运行的时候接受代码的提取

注解就是给代码打标签，这些标签不会影响到被标签代码的运行，但一些情况下程序会根据这些标签运行某些逻辑。
## 注解分类
- 根据生命周期活运行周期
	- 源码注。只在源码中存在
	- 编译时注解。在源码和class中存在 @Override 
	- 运行时注解。在运行时仍然存在 @Autowired
- 根据来源
	- JDK
	- 第三方
	- 自定义

## 元注解
给注解使用的注解，自定义注解中会使用到。

	@Target 在什么地方使用
	@Retention 运行周期
	@Documented 容许生成JavaDoc
	@Inherited 容许子类继承父类的该注解
	@Repeatable 1.8后，可重复使用

#### @Target

	ElemenetType.CONSTRUCTOR 构造器声明
	ElemenetType.FIELD 域声明（包括 enum 实例）
	ElemenetType.LOCAL_VARIABLE 局部变量声明
	ElemenetType.METHOD 方法声明
	ElemenetType.PACKAGE 包声明
	ElemenetType.PARAMETER 参数声明
	ElemenetType.TYPE 类，接口（包括注解类型）或enum声明
#### @Retention

	RetentionPolicy.SOURCE 在源码中
	RetentionPolicy.CLASS 在class中存在
	RetentionPolicy.RUNTIME 在运行中使用,可以通过反射调用注解信息

## 实例DEMO
#### 通过注解生成SQL
MyTypeAnnotation
```
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * 类上注解
 * @author RYF
 *
 */
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface MyTypeAnnotation {
	String value();
}
```
MyFieldAnnotation
```
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * 字段上的注解
 * @author RYF
 *
 */
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface MyFieldAnnotation {

	String value();
	
}
```
UserBean
```
/**
 * 模拟用户对象
 * @author RYF
 *
 */
@MyTypeAnnotation("user")
public class UserBean {

	@MyFieldAnnotation("id")
	private Integer id;
	
	@MyFieldAnnotation("name")
	private String name;
	
	@MyFieldAnnotation("sex")
	private Integer sex;

	 
	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public Integer getId() {
		return id;
	}

	public void setId(Integer id) {
		this.id = id;
	}

	public Integer getSex() {
		return sex;
	}

	public void setSex(Integer sex) {
		this.sex = sex;
	}
}
```
Test
```
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

/**
 * 注解使用方式测试
 * @author RYF
 *
 */
public class Test {
	
	public static void main(String[] args) {
		UserBean user1 = new UserBean();
		user1.setName("zhangsan");
		String result = query(user1);
		System.out.println(result);
		/**
		 * Output
		 * SELECT * FROM user where 1=1  and name=zhangsan
		 * 
		 */
		UserBean user2 = new UserBean();
		user2.setId(12);
		String result2 = query(user2);
		System.out.println(result2);
		/**
		 * Output
		 * SELECT * FROM user where 1=1  and id=12
		 * 
		 */
		
	}
	
	/**
	 * 组合查询语句并返回
	 * @param user 用户对象
	 * @return 返回查询语句
	 */
	public static String query(UserBean user) {
		
		StringBuffer sb = new StringBuffer();
		sb.append("SELECT * FROM ");
		
		//获取类上的表名注解
		MyTypeAnnotation table = user.getClass().getAnnotation(MyTypeAnnotation.class);
		if(table != null) {
			String tableName = table.value();
			sb.append(tableName +" where 1=1 " );
		}
		
		//获取所有的字段
		Field[] fields = user.getClass().getDeclaredFields();
		for (Field field : fields) {
			
			//获取字段上列名注解
			MyFieldAnnotation column = field.getAnnotation(MyFieldAnnotation.class);
			if(column != null) {
				//列名
				String columnName = column.value();
				//字段名
				String fieldName = field.getName();
				//通过字段名组合get方法名称
				String fieldGetMethodName = "get"+fieldName.substring(0, 1).toUpperCase()+fieldName.substring(1);
				try {
					//反射获取方法的值
					Method fieldMethod = user.getClass().getMethod(fieldGetMethodName);
					Object fieldValue =  fieldMethod.invoke(user);
					if(fieldValue == null) {
						continue;
					}
					//值不为空则作为条件
					sb.append(" and "+columnName+"="+ fieldValue);
				}  catch (NoSuchMethodException e) {
					e.printStackTrace();
				} catch (SecurityException e) {
					e.printStackTrace();
				}catch (IllegalAccessException e) {
					e.printStackTrace();
				} catch (IllegalArgumentException e) {
					e.printStackTrace();
				} catch (InvocationTargetException e) {
					e.printStackTrace();
				}
			}
		}
		return sb.toString();
	}
}
```
*注：该DEMO只是为了演示自定义注解及使用，生成的SQL逻辑不严谨*

#### 方法注解DEMO
LogAnnotation
```
/**
 * 日志注解
 * @author RYF
 *
 */
@Target({ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface LogAnnotation {
	String desc(); //操作描述信息
	int operType() ;//操作类型 默认未分类 
	int operModule() ;//操作模块 默认未分类
	int operUserId() default 0;//操作用户ID
	String operDate() default "";//操作时间
	String operIp() default "";//操作ip
	int operResult() default 0;// 1 正常 0 异常
	String exceptionDesc() default ""; //异常描述
	String note() default "";//备注
}
```
方法使用

	@LogAnnotation(desc="新增/注册用户",operType = 1,operModule=1)
	public UserBean login(UserBean user) {
		return userDao.searchUserByNameAndPwd(user);
	}
日志调用

	LogAnnotation log = method.getAnnotation(LogAnnotation.class);

*注：该注解可配合springAOP使用用来记录日志*

## 参考资料
- https://blog.csdn.net/briblue/article/details/73824058


